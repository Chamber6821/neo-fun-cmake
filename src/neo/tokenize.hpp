#pragma once

#include "./concepts.hpp"
#include "./fwd.hpp"
#include "./invoke.hpp"
#include "./iterator_facade.hpp"
#include "./reconstruct.hpp"
#include "./text_range.hpp"

#include "./enum.hpp"

#include <algorithm>

namespace neo {

/**
 * @brief A simple token type that stores a single view of a text range.
 *
 * @tparam View The type of the text view
 */
template <text_view View>
struct simple_token {
    /// The view of the token text.
    View view;
    /// The point at which to begin searching for the next token
    std::ranges::iterator_t<View> skip{};
};

template <typename FindSplit>
struct simple_token_splitter {
    [[no_unique_address]] FindSplit _find_split;

    template <text_view View>
    constexpr std::optional<simple_token<View>> operator()(View prev,
                                                           View remaining) const noexcept {
        if (std::ranges::empty(remaining)
            and std::ranges::end(prev) == std::ranges::end(remaining)) {
            // The previous token ends at the end of the input stream, which indicates that the full
            // text view does not end with a splitting sequence. Do not yield another token.
            return std::nullopt;
            // If we are at the end of the remaining input stream and there was a splitter, we will
            // end up returning an empty token for the end of the text.
        }

        // Find the next splitter:
        View split = _find_split(remaining);

        // Get the text leading up to the new split
        auto tok = neo::reconstruct_range(remaining,
                                          std::ranges::begin(remaining),
                                          std::ranges::begin(split));

        return simple_token{tok, std::ranges::end(split)};
    }
};

template <typename C>
requires std::predicate<C, char32_t>
struct charclass_splitter {
    [[no_unique_address]] C _classifier{};

    template <text_view V>
    requires reconstructible_range<V>
    constexpr V operator()(V remaining) const noexcept {
        auto skip_start
            = std::ranges::find_if(remaining, [&](char32_t c) { return _classifier(c); });
        auto skip_end = std::ranges::find_if(skip_start,
                                             std::ranges::end(remaining),
                                             [&](char32_t c) { return not _classifier(c); });
        return neo::reconstruct_range(remaining, skip_start, skip_end);
    }
};

struct is_whitespace_fn {
    constexpr auto operator()(char32_t c) const {
        return c == ' ' or c == '\n' or c == '\r' or c == '\t' or c == '\f';
    }
};

struct find_newline_fn {
    constexpr auto operator()(neo::text_view auto view) const {
        auto v = neo::view_text(view);
        while (not v.empty() and not v.starts_with("\n") and not v.starts_with("\r\n")) {
            v.remove_prefix(1);
        }
        if (v.starts_with("\r\n")) {
            return neo::reconstruct_range(view, v.begin(), v.begin() + 2);
        } else if (v.starts_with("\n")) {
            return neo::reconstruct_range(view, v.begin(), v.begin() + 1);
        }
        // "v" is empty:
        return neo::reconstruct_range(view, v.begin(), v.end());
    }
};

/**
 * @brief A simple tokenizer that splits text on whitespace.
 */
struct whitespace_splitter : simple_token_splitter<charclass_splitter<is_whitespace_fn>> {};
struct line_splitter : simple_token_splitter<find_newline_fn> {};

template <typename T, typename Text>
concept token_type = requires(T&& token) {
    { token.view } -> std::convertible_to<view_text_t<Text>>;
};

template <typename T, typename Text>
concept token_result = neo::simple_boolean<T> && requires(T&& token) {
    { *token } -> token_type<Text>;
};

template <typename Func, typename Text>
concept tokenizer_fn =  //
    neo::invocable2<Func,
                    view_text_t<Text>,
                    view_text_t<Text>>  //
    && text_range<Text>                 //
    && token_result<neo::invoke_result_t<Func, view_text_t<Text>, view_text_t<Text>>, Text>;

/**
 * @brief A tokenizer object. Splits a text_range into a range of tokens
 *
 * @tparam R The type of the text range that is being split
 * @tparam Tok The tokenization function
 */
template <text_range R, tokenizer_fn<view_text_t<R>> Tok>
class tokenizer {
    /// The text that is being tokenized
    R _text;
    /// The token-splitting function
    [[no_unique_address]] Tok _get_next_token;

public:
    /**
     * @brief Construct a new tokenizer from a text range and token splitter
     */
    constexpr explicit tokenizer(R&& text, Tok&& tkz) noexcept
        : _text(NEO_FWD(text))
        , _get_next_token(NEO_FWD(tkz)) {}

    /// The type of the token that is generated by this tokenizer
    using token_result = invoke_result_t<Tok&, view_text_t<R>, view_text_t<R>>;

    /**
     * @brief The iterator that walks the range of tokens
     */
    struct iterator : iterator_facade<iterator> {
    private:
        view_text_t<R> _tail;
        token_result   _current;

        std::remove_reference_t<Tok>* _tokenize = nullptr;

    public:
        iterator() = default;

        struct sentinel_type {};

        explicit iterator(view_text_t<R> v, Tok& tok)
            : _tail(v)
            , _tokenize(neo::addressof(tok)) {
            increment();
        }

        constexpr const auto& dereference() const noexcept { return _current.value(); }

        constexpr void
        increment() noexcept(noexcept(neo::invoke(*_tokenize, _current->view, _tail))) {
            _current = neo::invoke(*_tokenize, _current->view, _tail);
            // Reconstruct the tail:
            if (_current) {
                _tail = reconstruct_range(_tail, _current->skip, std::ranges::end(_tail));
            }
        }

        constexpr bool operator==(sentinel_type) const { return not static_cast<bool>(_current); }
        constexpr bool operator==(iterator other) const noexcept {
            return std::ranges::data(_tail) == std::ranges::data(other._tail);
        }
    };

    constexpr iterator begin() noexcept { return iterator{neo::view_text(_text), _get_next_token}; }

    constexpr auto end() noexcept { return typename iterator::sentinel_type{}; }
};

template <text_range R, tokenizer_fn<view_text_t<R>> Tok>
explicit tokenizer(R&&, Tok&&) -> tokenizer<R, Tok>;

}  // namespace neo

namespace std::ranges {

/// A tokenizer is a borrowed range if its text type is a borrowed range.
template <typename R, typename Tok>
constexpr bool enable_borrowed_range<neo::tokenizer<R, Tok>> = std::ranges::borrowed_range<R>;

template <typename R, typename Tok>
constexpr bool enable_view<neo::tokenizer<R, Tok>> = std::ranges::view<R>and
               std::is_trivially_copyable_v<Tok>;

}  // namespace std::ranges
